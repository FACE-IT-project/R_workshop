---
# title: Domesticating data
format:
  revealjs:
    theme: FACE-IT_pres.scss
    self-contained: true
    transition: slide
editor: source
---

# Domesticating data {background-color="#008980" style="text-align: center"}

*Robert Schlegel*

```{r maps-1-opts, echo=FALSE}
knitr::opts_chunk$set(
  warning = FALSE, 
  message = FALSE,
  echo = TRUE
)
```

## Problem

-   How do we summarise our data if they have multiple categories?

## Solution

-   `group_by()` provides powerful options for data analysis

## Setup

```{r}
library(tidyverse) # All-in-one

sst_NOAA <- read_csv("course_material/data/sst_NOAA.csv") # SST data
```

## The next level

In the previous session we covered the five main transformation functions one would use in a typical **tidy** workflow. But to really unlock their power we need to learn how to use them with `group_by()`. This is how we may calculate statistics based on the different grouping variables within our data, such as sites or species or months.

## `group_by()`

- Note that this function will not appear to do anything by itself
- This can cause issues if we aren't paying attention

```{r}
sst_NOAA_site <- sst_NOAA %>% group_by(site)
```

::: columns
::: {.column}
```{r}
sst_NOAA %>% head()
```
:::

::: {.column}
```{r}
sst_NOAA_site %>% head()
```
:::
:::

## `group_by()`

-   But when we `summarise()` the data...

::: columns
::: {.column}
```{r}
sst_NOAA %>% 
  summarise(mean_temp = mean(temp, na.rm = TRUE)) %>% 
  head()
```
:::

::: {.column}
```{r}
sst_NOAA_site %>% 
  summarise(mean_temp = mean(temp, na.rm = TRUE)) %>% 
  head()
```
:::
:::

## `ungroup() `

-   One must explicitly tell R to remove a group

```{r}
sst_NOAA_ungroup <- sst_NOAA_site %>% ungroup()
```

::: columns
::: {.column}
```{r}
sst_NOAA_site %>% 
  summarise(mean_temp = mean(temp, na.rm = TRUE)) %>% 
  head()
```
:::

::: {.column}
```{r}
sst_NOAA_ungroup %>% 
  summarise(mean_temp = mean(temp, na.rm = TRUE)) %>% 
  head()
```
:::
:::

## Multiple groups

-   As one may have guessed by now, grouping is not confined to a single column
-   One may use any number of columns to perform elaborate grouping measures


```{r, eval=FALSE}
# Create groupings based on temperatures
sst_NOAA_temp_group <- sst_NOAA %>% 
  group_by(round(temp))

# Create groupings based on site and month
sst_NOAA_temp_month_group <- sst_NOAA %>% 
  mutate(month = month(t)) %>% 
  group_by(site, month)
```

## Chain functions

-   Generally we do not group objects separately
-   Grouping is performed within code chunks

```{r}
sst_NOAA_site_mean <- sst_NOAA %>% # Choose a base dataframe
  group_by(site) %>% # Group by the site column
  summarise(mean_temp = mean(temp, na.rm = TRUE), # Calculate means
            count = n() # Count observations
            ) # Safety measure
sst_NOAA_site_mean
```

## Grouped transformations

We've played around quite a bit with grouping and summarising, but that's not all we can do. We can use `group_by()` very nicely with `filter()` and `mutate()` as well. Not so much with `arrange()` and `select()` as these are designed to work on the entire dataframe at once, without any subsetting.

We can do some rather imaginative things when we combine all of these tools together. In fact, we should be able to accomplish almost any task we can think of. For example, what if we wanted to create a new object that was a subset of only the sites in the `SACTN` that had at least 30 years (360 months) of data?

```{r tidiest-group-6, eval=FALSE}
SACTN_30_years <- SACTN %>%
  group_by(site, src) %>%
  filter(n() > 360) %>% 
  ungroup()
```

Or what if we wanted to calculate anomaly data for each site?

```{r tidiest-group-7, eval=FALSE}
SACTN_anom <- SACTN %>%
  group_by(site, src) %>% 
  mutate(anom = temp - mean(temp, na.rm = T)) %>% 
  select(site:date, anom, depth, type) %>% 
  ungroup()
```

Now, let's select only two sites and calculate their mean and standard deviations. Note how whichever columns we give to `group_by()` will be carried over into the new dataframe created by `summarise()`.

```{r tidiest-group-8}
SACTN %>% 
  filter(site == "Paternoster" | site == "Oudekraal") %>%
  group_by(site, src) %>% 
  summarise(mean_temp = mean(temp, na.rm = TRUE), 
            sd_temp = sd(temp, na.rm = TRUE))
```

## Going deeper

We learned in the previous session that one should avoid using comparison operators to compare logical arguments as this tends to not produce the results one would expect. Below we see what happens when we try to repeat the code chunk above, but using a logical operator within a comparison operator.

```{r tidiest-logic-1, error=TRUE}
SACTN %>% 
  filter(site == "Paternoster" | "Oudekraal") %>% # This line has been changed/shortened
  group_by(site, src) %>% 
  summarise(mean_temp = mean(temp, na.rm = TRUE), 
            sd_temp = sd(temp, na.rm = TRUE))
```

Oh no, we broke it! This is a common error while learning to write code so do try to keep this rule in mind as it can cause a lot of headaches. An easy way to spot this problem is if ones line of code has more logical operators than comparison operators you're probably going to have a bad time. This is doubly unfortunate as we would need to write less code if this were not so. Happily, there is a shortcut for just this problem, `%in%`. Whenever we want to use operators to filter by more than two things, it is most convenient to create an object that contains the names or numbers that we want to filter by. We then replace our comparison and logical operators with that one simple symbol (`%in%`). 

```{r tidiest-logic-2}
# First create a character vector containing the desired sites
selected_sites <- c("Paternoster", "Oudekraal", "Muizenberg", "Humewood")

# Then calculate the statistics
SACTN %>% 
  filter(site %in% selected_sites) %>%
  group_by(site, src) %>% 
  summarise(mean_temp = mean(temp, na.rm = TRUE), 
            sd_temp = sd(temp, na.rm = TRUE))
```

The `%in%` operator can be a very useful shortcut, but sometime we cannot avoid the comparison and logical operator dance. For example, if one wanted to find temperatures at Port Nolloth that were over 10°C but under 15°C you could use either of the following two filters. Remember that whenever we see a `,` in the filter function it is the same as the `&` logical operator. Of the two different techniques shown below, I would be more inclined to use the first one. The fewer symbols we use to write our code the better. Both for readability and error reduction.

```{r, eval = FALSE}
SACTN %>% 
  filter(site == "Port Nolloth", temp > 10, temp < 15)

SACTN %>% 
  filter(site == "Port Nolloth", !(temp <= 10 | temp  >= 15))
```

As one may imagine, performing intricate logical arguments like this may get out of hand rather quickly. It is advisable to save intermediate steps in a complex workflow to avoid too much heartache. Where exactly these 'fire breaks' should be made is up to the person writing the code.

<!-- ## Expand -->

<!-- ## Applied stats -->

## Pipe into **`ggplot2`**

It is also possible to combine piped code chunks and **`ggplot2`** chunks into one 'combi-chunk'. I prefer not to do this as I like saving the new dataframe I have created as an object in my environment before visualising it so that if anything has gone wrong (as things tend to do) I can more easily find the problem.

Regardless of what one may or may not prefer to do, the one thing that must be mentioned about piping into **`ggplot2`** is that when we start with the `ggplot()` function we switch over from the pipe (`%>%`)
to the plus sign (`+`). There are currently efforts to address this inconvenience, but are not yet ready for public consumption.

```{r}
SACTN %>% # Choose starting dataframe
  filter(site %in% c("Bordjies", "Tsitsikamma", "Humewood", "Durban")) %>% # Select sites
  select(-depth, -type) %>% # Remove depth and type columns
  mutate(month = month(date), # Create month column
         index = paste(site, src, sep = "/ ")) %>% # Create individual site column
  group_by(index, month) %>% # Group by individual sites and months
  summarise(mean_temp = mean(temp, na.rm = TRUE), # Calculate mean temperature
            sd_temp = sd(temp, na.rm = TRUE)) %>% # Calculate standard deviation
  ggplot(aes(x = month, y = mean_temp)) + # Begin with ggplot, switch from '%>%' to '+'
  geom_ribbon(aes(ymin = mean_temp - sd_temp, ymax = mean_temp + sd_temp), 
              fill = "black", alpha = 0.4) + # Create a ribbon
  geom_line(col = "red", size = 0.3) + # Create lines within ribbon
  facet_wrap(~index) + # Facet by individual sites
  scale_x_continuous(breaks = seq(2, 12, 4)) + # Control x axis ticks
  labs(x = "Month", y = "Temperature (°C)") + # Change labels
  theme_dark() # Set theme
```

## Additional useful functions

There is an avalanche of useful functions to be found within the **`tidyverse`**. In truth, we have only looked at functions from three packages: **`ggplot2`**, **`dplyr`**, and **`tidyr`**. There are far, far too many functions even within these three packages to cover within a week. But that does not mean that the functions in other packages, such as **`purrr`** are not also massively useful for our work. More on that tomorrow. For now we will see how the inclusion of a handful of choice extra functions may help to make our workflow even tidier.

## Rename variables (columns) with `rename()`

We have seen that we select columns in a dataframe with `select()`, but if we want to rename columns we have to use, you guessed it, `rename()`. This functions works by first telling R the new name you would like, and then the existing name of the column to be changed. This is perhaps a bit back to front, but such is life on occasion.

```{r tidiest-rename, eval=FALSE}
SACTN %>% 
  rename(source = src)
```
```{r tidiest-rename-ghost, echo=FALSE}
rename(SACTN, source = src)[1:10,]
```

## Create a new dataframe for a newly created variable (column) with `transmute()`

If for whatever reason one wanted to create a new variable (column), as one would do with `mutate()`, but one does not want to keep the dataframe from which the new column was created, the function to use is `transmute()`.

```{r tidiest-transmute-1, eval=FALSE}
SACTN %>% 
  transmute(kelvin = temp + 273.15)
```
```{r tidiest-transmute-1-ghost, echo=FALSE}
transmute(SACTN, kelvin = temp + 273.15)[1:10,]
```

This makes a bit more sense when paired with `group_by()` as it will pull over the grouping variables into the new dataframe. Note that when it does this for us automatically it will provide a message in the console.

```{r tidiest-transmute-2, eval=FALSE}
SACTN %>% 
  group_by(site, src) %>% 
  transmute(kelvin = temp + 273.15)
```
```{r tidiest-transmute-2-ghost, echo=FALSE}
SACTN_trans <- SACTN %>% 
  group_by(site, src) %>% 
  transmute(kelvin = temp + 273.15)
SACTN_trans[1:10,]
```

## Count observations (rows) with `n()`

We have already seen this function sneak it's way into a few of the code chunks in the previous session. We use `n()` to count any grouped variable automatically. It is not able to be given any arguments, so we must organise our dataframe in order to satisfy it's needs. It is the diva function of the **`tidyverse`**; however, it is terribly useful as we usually want to know how many observations our summary stats are based. First we will run some stats and create a figure without documenting `n`. Then we will include `n` and see how that changes our conclusions.

```{r tidiest-n-1, fig.cap="Dot plot showing range of mean temperatures for the time series in the SACTN dataset."}
 SACTN_n <- SACTN %>% 
  group_by(site, src) %>% 
  summarise(mean_temp = round(mean(temp, na.rm = T))) %>% 
  arrange(mean_temp) %>% 
  ungroup() %>% 
  select(mean_temp) %>% 
  unique()

ggplot(data = SACTN_n, aes(x = 1:nrow(SACTN_n), y = mean_temp)) +
  geom_point() +
  labs(x = "", y = "Temperature (°C)") +
  theme(axis.text.x = element_blank(), 
        axis.ticks.x = element_blank())
```

This looks like a pretty linear distribution of temperatures within the SACTN dataset. But now let's change the size of the dots to show how frequently each of these mean temperatures is occurring.

```{r tidiest-n-2, fig.cap="Dot plot showing range of mean temperatures for the time series in the SACTN dataset with the size of each dote showing the number of occurences of each mean."}
 SACTN_n <- SACTN %>% 
  group_by(site, src) %>% 
  summarise(mean_temp = round(mean(temp, na.rm = T))) %>% 
  ungroup() %>% 
  select(mean_temp) %>% 
  group_by(mean_temp) %>% 
  summarise(count = n())

ggplot(data = SACTN_n, aes(x = 1:nrow(SACTN_n), y = mean_temp)) +
  geom_point(aes(size = count)) +
  labs(x = "", y = "Temperature (°C)") +
  theme(axis.text.x = element_blank(), 
        axis.ticks.x = element_blank())
```

We see now when we include the count (`n`) of the different mean temperatures that this distribution is not so even. There appear to be humps around 17°C and 22°C. Of course, we've created dot plots here just to illustrate this point. In reality if one were interested in a distribution like this one would use a histogram, or better yet, a density polygon.

```{r  tidiest-n-3, fig.cap="Frequency distribution of mean temperature for each time series in the SACTN dataset."}
SACTN %>% 
  group_by(site, src) %>% 
  summarise(mean_temp = round(mean(temp, na.rm = T))
            ) %>% 
  ungroup() %>% 
  ggplot(aes(x = mean_temp)) +
  geom_density(fill = "seagreen", alpha = 0.6) +
  labs(x = "Temperature (°C)")
```

### Select observations (rows) by number with `slice()`

If one wants to select only specific rows of a dataframe, rather than using some variable like we do for `filter()`, we use `slice()`. The function expects us to provide it with a series of integers as seen in the following code chunk. Try playing around with these values and see what happens

```{r tidiest-slice-1, eval=FALSE}
# Slice a seqeunce of rows
SACTN %>% 
  slice(10010:10020)

# Slice specific rows
SACTN %>%
  slice(c(1,8,19,24,3,400))

# Slice all rows except these
SACTN %>% 
  slice(-(c(1,8,4)))

# Slice all rows except a sequence
SACTN %>% 
  slice(-(1:1000))
```

It is discouraged to use slice to remove or select specific rows of data as this does not discriminate against any possible future changes in ones data. Meaning that if at some point in the future new data are added to a dataset, re-running this code will likely no longer be selecting the correct rows. This is why `filter()` is a main function, and `slice()` is not. This auxiliary function can however still be quite useful when combined with arrange.

```{r tidiest-slice-2}
# The top 5 variable sites as measured by SD
SACTN %>% 
  group_by(site, src) %>% 
  summarise(sd_temp = sd(temp, na.rm = T)) %>% 
  ungroup() %>% 
  arrange(desc(sd_temp)) %>% 
  slice(1:5)
```

## Summary functions

There is a near endless sea of possibilities when one starts to become comfortable with writing R code. We have seen several summary functions used thus far. Mostly in straightforward ways. But that is one of the fun things about R, the only limits to what we may create are within our mind, not the program. Here is just one example of a creative way to answer a straightforward question: 'What is the proportion of recordings above 15°C per source?'. Note how we may refer to columns we have created within the same chunk. There is no need to save the intermediate dataframes if we choose not to.
    
```{r tidiest-summary}
SACTN %>% 
  na.omit() %>% 
  group_by(src) %>%
  summarise(count = n(), 
            count_15 = sum(temp > 15)) %>% 
  mutate(prop_15 = count_15/count) %>% 
  arrange(prop_15)
```

## The new age *redux*

Remember the spreadsheet example from the first day of the R workshop? Here it is repeated in a more efficient way. Now with bonus ribbons! In this chunk we see how to load, transform, and visualise the data all in one go. One would not normally do this, but it sure is snappy!

```{r tidiest-new-age}
read_csv("../data/sst_NOAA.csv") %>% # Load the SACTN Day 1 data
  mutate(month = month(t, label = T)) %>% # Then create a month abbreviation column
  group_by(site, month) %>% # Then group by sites and months
  summarise(mean_temp = mean(temp, na.rm = TRUE), # Lastly calculate the mean
            sd_temp = sd(temp, na.rm = TRUE)) %>% # and the SD
  ggplot(aes(x = month, y = mean_temp, group = site)) + # Begin ggplot
  geom_ribbon(aes(ymin = mean_temp - sd_temp, ymax = mean_temp + sd_temp), 
              fill = "black", alpha = 0.4) + # Create a ribbon
  geom_point(aes(colour = site)) + # Create dots
  geom_line(aes(colour = site, group = site)) + # Create lines
  labs(x = "Month", y = "Temperature (°C)", colour = "Site") # Change labels
```