{
  "hash": "eb793752ebbbd3ae0094f5c263c545f3",
  "result": {
    "markdown": "---\ntitle: \"Bonus\"\neditor: source\nlink-external-newwindow: true\n---\n\n::: {.cell}\n\n:::\n\n\n# Data mangling\n\nThis script shows the steps I took to prepare the mangled dataframes used in the tidy data examples in this workshop.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load libraries\nlibrary(tidyverse)\nlibrary(lubridate)\n\n# Load data\nsst_NOAA <- read_csv(\"course_material/data/sst_NOAA.csv\")\n```\n:::\n\n\n## Mangle\n\nAnd now begins the mangling.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sites to extract\nsites <- c(\"Med\", \"NW_Atl\", \"WA\")\n\n# Create tidy base\nOISST_tidy <- sst_NOAA %>%\n  mutate(year = year(t)) %>%\n  filter(site %in% sites,\n         year %in% c(2008, 2009)) %>%\n  select(-year)\n\n# First mangle\n  # Normal tidy data\nOISST1 <- OISST_tidy\n\n# Second mangle\nOISST2 <- OISST_tidy %>%\n  pivot_wider(names_from = site, values_from = temp)\n\n# Third mangle\nOISST3 <- OISST_tidy %>%\n  mutate(t = as.character(t),\n         idx = 1:n()) %>% \n  pivot_longer(cols = c(site, t), names_to = \"type\", values_to = \"name\") %>% \n  dplyr::select(idx, type, name, temp)\n\n## Fourth two part mangle\n# A\nOISST4a <- OISST_tidy %>%\n  mutate(t = as.character(t)) %>%\n  unite(index, site, t, sep = \" \")\n\n# B\nOISST4b <- OISST_tidy %>%\n  mutate(t = as.character(t),\n         idx = 1:n()) %>%\n  separate(col = t, into = c(\"year\", \"month\", \"day\"), sep = \"-\") %>%\n  select(-temp)\n```\n:::\n\n\n## Save\n\nHere we save all five of the newly mangled dataframes as one .RData object for ease of loading in the tutorial.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsave(list = c(\"OISST1\", \"OISST2\", \"OISST3\", \"OISST4a\", \"OISST4b\"), file = \"course_material/data/OISST_mangled.RData\")\n```\n:::\n\n\n# Animations\n\nIn this supplemental tutorial we are going to look at how to create animations in R. To do this will require the installation of software outside of R. This software is `ImageMagick` and may be downloaded here: <https://www.imagemagick.org/script/download.php>. Once this software has been installed on your computer it will be necessary to install the `animation` library.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The libraries required for this tut\nlibrary(tidyverse)\nlibrary(grid)\nlibrary(gridExtra)\nlibrary(animation)\n```\n:::\n\n\n## Functions for creating ant walks\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate speed based on u and v vectors\nant.speed <- function(df){\n  df$x2 <- c(NA,df$x[2:nrow(df)] - df$x[1:(nrow(df)-1)])\n  df$y2 <- c(NA,df$y[2:nrow(df)] - df$y[1:(nrow(df)-1)])\n  speed_abs <- round(sqrt(df$x2^2 + df$y2^2),2)\n  speed_abs[is.na(speed_abs)] <- 0\n  return(speed_abs)\n}\n\n# Create a dataframe with desired number of ants and steps\nant.walk <- function(i,n){\n  # Create the random walks\n  walk_x <- c(0,round(cumsum(rnorm(n = n-1, mean = 0, sd = 1)),2))\n  for(i in 2:i){\n  x <- c(0,round(cumsum(rnorm(n = n-1, mean = 0, sd = 1)),2))\n  walk_x <- c(walk_x, x)\n  }\n  walk_y <- c(0,round(cumsum(rnorm(n = n-1, mean = 0, sd = 1)),2))\n  for(i in 2:i){\n  y <- c(0,round(cumsum(rnorm(n = n-1, mean = 0, sd = 1)),2))\n  walk_y <- c(walk_y, y)\n  }\n  # Create the walking dataframe\n  walker <- data.frame(x = walk_x, y = walk_y, \n                       ant = as.factor(rep(1:i, each = n)), \n                       step =  rep(seq(1,n), i))\n  walker$speed <- ant.speed(walker)\n  walker$speed[walker$step == 1] <- 0\n  return(walker)\n}\n```\n:::\n\n\n## Generate the ants\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Increase the second number for a longer animation\nants <- ant.walk(5, 20)\n```\n:::\n\n\n## The function to animate the walk plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwalk.plot <- function(i){\n  # Map figure\n  walk_map <- ggplot(data = ants[ants$step %in% 1:i,], aes(x = x, y = y)) +\n    geom_path(aes( group = ant), colour = \"gray60\") +\n    geom_point(data = ants[ants$step == i,], aes(colour = ant))\n  # Speed histogram\n  walk_hist <- ggplot(data = ants[ants$step %in% 1:i,], aes(x = speed)) +\n    geom_histogram() +\n    labs(x = \"speed\")\n  # Speed line graph\n  walk_line <- ggplot(data = ants[ants$step %in% 1:i,], aes(x = step, y = speed)) +\n    geom_line(aes(colour = ant))\n  # Wack it together\n  grid.arrange(walk_map, walk_hist, walk_line, layout_matrix = cbind(c(1,1), c(1,1), c(2,3)))\n}\n\n## Create animation of ts plots\nanimate.walk.plot <- function() {\n  lapply(seq(1, max(ants$step)), function(i) {\n    walk.plot(i)\n  })\n}\n```\n:::\n\n\n## Render the GIF\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# By default 'saveGIF()' outputs to the same folder as from where the script is.\n# I have included the lines here to change your working directory and then change it back.\n# Be careful here! This can be easy to cause issues.\nsetwd(\"course_material/\")\nsystem.time(saveGIF(animate.walk.plot(), interval = 0.2, \n                    ani.width = 800, movie.name = \"ant_walk.gif\")) ## ~60 seconds\nsetwd(\"../\")\n```\n:::\n\n\n# GIFs on plots\n\nYes my friends, it is true. We may add GIFs to our figures and maps. Rejoice. Better yet, the process is relatively straight forward. We will begin, as usual, by loading our libraries and files.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load libraries\nlibrary(tidyverse)\nlibrary(magick)\n\n# The base image\nbackground <- image_read(\"images/EU_flag.jpg\") %>% # Load file\n  image_scale(\"900\") # Change resolution\n\n# The gif to overlay\nanim_overlay <- image_read(\"course_material/ant_walk.gif\")  %>% # Load file \n  image_scale(\"300\") # Change resolution\n```\n:::\n\n\n## GIF creation\n\nOnce we have loaded our base image and the GIF we want to put on top of it we need to create a function to make these two different file types 'kiss'. With the appropriately named **`magick`** package this is startlingly easy to do.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nframes <- lapply(anim_overlay, function(frame) {\n  image_composite(background, frame, offset = \"+300\")\n})\n```\n:::\n\n\n## GIF animation\n\nWith our function for creating the GIF sorted, it is now time to animate it!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanimation <- image_animate(image_join(frames), fps = 10) # FPS = 10 is native speed\n```\n:::\n\n\n## GIF save\n\nJip. Simple as that.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimage_write(animation, \"course_material/EU_ants.gif\")\n```\n:::\n\n\n# Morphing\n\nHave you ever wanted to animate the transition from one figure to another? No? Me neither. But hey, it's easy to do, so why not.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load libraries\nlibrary(magick)\n\n# Load images\nnewlogo <- image_scale(image_read(\"https://www.r-project.org/logo/Rlogo.png\"), \"x150\")\noldlogo <- image_scale(image_read(\"https://developer.r-project.org/Logo/Rlogo-3.png\"), \"x150\")\n```\n:::\n\n\n## Morph creation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmorph_frames <- image_morph(c(oldlogo, newlogo), frames = 100)\n```\n:::\n\n\n## Morph animation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmorph_animate <- image_animate(morph_frames, fps = 20)\n```\n:::\n\n\n## Morph save\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimage_write(morph_animate, \"course_material/morph.gif\")\n```\n:::\n\n\n# Multivariate stats\n\n> To err is human, but to really foul things up you need a computer.\n>\n> ---*Paul R. Ehrlich*\n\nIn this brief tutorial we are going to walk through the steps necessary to perform a most basic ordination. We will be using MDS for this as it produces, in my opinion, the most straight forward results. There is of course an entire school of thought on this and I, a mere climate scientist, am in no way an authoritative voice on the matter.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load libraries\nlibrary(tidyverse)\nlibrary(ggpubr)\nlibrary(vegan)\n\n# Load built-in data\ndata(\"dune\")\ndata(\"dune.env\")\n```\n:::\n\n\n## MDS\n\nMDS, or multi-dimensional scaling, is high level clustering technique. MDS allows us to determine which of the abiotic variables in our dataset are having the most pronounced effects on the clustering of the dunes. Running an MDS on a data frame in R is simple as the `vegan` package will do all of the heavy lifting for us. First we will jump straight in and run an MDS, then we will take a step back and try changing the standardisation of the values and the distance matrix that we would normally need to first calculate. Please consult the help file (`?metaMDS`) for details on the function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndune_MDS_1 <- metaMDS(dune)\n```\n:::\n\n\nOr we may be more specific in the way in which we prepare our data for the MDS. Look through the help files to see what other options exist.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Standardise data\ndune_stand <- decostand(dune, method = \"total\")\n\n# Create Bray-Curtis dissimilarity matrix\ndune_dist <- vegdist(dune_stand, method = \"bray\")\n\n# Create distance matrix\ndune_MDS_2 <- metaMDS(dune_dist)\n```\n:::\n\n\n## Stress\n\nNo, not that stress. We are talking about the stress of the MDS model now. This is an important value to check. If the stress is high (>0.3) the MDS model is doing a poor job of modeling the dissimilarities in the data. If it is low (<0.1) the model is doing a very good job of displaying the relationships within the data. To check the stress of our results we use the following line of code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Default MDS settings\ndune_MDS_1$stress\n\n# Determined settings\ndune_MDS_2$stress\n```\n:::\n\n\nWhat is the stress of this model? Is that an acceptable level?\n\n## Basic biplot\n\nWith the MDS calculated, and the stress tested, it's time to visualise the first round of results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert for ggplot\ndune_MDS_points <- data.frame(site = 1:nrow(dune)) %>%\n  mutate(x = as.numeric(dune_MDS_2$points[ ,1]),\n         y = as.numeric(dune_MDS_2$points[ ,2]))\n\n# Visualise with ggplot\nggplot(data = dune_MDS_points, aes(x = x, y = y)) +\n  geom_point(size = 8, shape = 21, fill = \"black\", colour = \"red\") +\n  geom_text(aes(label = site), colour = \"white\") +\n  labs(x = \"NMDS1\", y = \"NMDS2\")\n```\n:::\n\n\n## Fitting environmental variables\n\nAs with all of the other ordination analyses we have performed in R thus far, fitting environmental variables may also be done with one easy step. We do this by providing the `envfit()` function with a formula, the same as we do for linear models. The dependent variable (to the left of the `~`) will be the results of the MDS on the species assemblage data, and the independent variables (to the right of the `~`) are the columns from our environmental variables data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndune_envfit <- envfit(dune_MDS_2 ~ Moisture + Use, data = dune.env)\ndune_envfit\n```\n:::\n\n\nIn the printout above we see the results for the R^2 (here r2) and *p*-values for the fit of each abiotic variable to the species assemblage data. Which relationships are significant? Which variable(s) appears to best explain the variance in the species assemblages? Which of the axes of the MDS have the strongest relationship with which variable?\n\nTo plot the results of our fitted abiotic variables on top of our species MDS we need to quickly prep it to play nice with **`ggplot2`** and then we need only append a couple of lines onto the chunk we wrote to display our MDS results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract the envfit vector values\ndune_envfit_df <- data.frame(dune_envfit$factors$centroids) %>%\n  mutate(factors = row.names(.)) %>%\n  rename(x = NMDS1, y = NMDS2)\n\n# Visualise environmental fits\nggplot(data = dune_MDS_points, aes(x = x, y = y)) +\n  geom_point(size = 8, shape = 21, fill = \"black\", colour = \"red\") +\n  geom_text(aes(label = site), colour = \"white\") +\n  geom_segment(data = dune_envfit_df, arrow = arrow(length = unit(0.25, \"cm\")),\n               aes(x = 0, y = 0, xend = x, yend = y)) +\n  geom_text(data = dune_envfit_df, colour = \"red\", \n            aes(x = x, y = y, label = factors)) +\n  labs(x = \"NMDS1\", y = \"NMDS2\")\n```\n:::\n\n\n## Adding clusters\n\nIn order to add clustering we must first create groupings for our data. In this instance we will be calculating our groups using hierarchical cluster analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create dendrogram\n  # Note that this must be run on a distance matrix\ndune_clust <- hclust(dune_dist, \"ward.D\")\n\n# Extract clusters\n  # In this case we have decided on four clusters\ndune_grp <- cutree(dune_clust, 4)\n\n# Extract groups for plotting\ndune_MDS_points <- dune_MDS_points %>% \n  mutate(grp_id = as.factor(dune_grp))\n```\n:::\n\n\nWith the clusters calculated we may now plot ellipses on our biplot. We will first do this with the built-in functionality of **`ggplot2`**, which unfortunately isn't great.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = dune_MDS_points, aes(x = x, y = y)) +\n  geom_point(size = 8, shape = 21, fill = \"black\", colour = \"red\") +\n  geom_text(aes(label = site), colour = \"white\") +\n  geom_segment(data = dune_envfit_df, arrow = arrow(length = unit(0.25, \"cm\")),\n               aes(x = 0, y = 0, xend = x, yend = y)) +\n  geom_text(data = dune_envfit_df, colour = \"red\", \n            aes(x = x, y = y, label = factors)) +\n  # The ellipses\n  stat_ellipse(aes(colour = grp_id), type = \"t\") + \n  #\n  labs(x = \"NMDS1\", y = \"NMDS2\", colour = \"Cluster\")\n```\n:::\n\n\nIf we have very large datasets the ellipses will come more in line with what we want. With small datasets not so much. This is because the ellipses are actually calculating the area under which a certain confidence interval is maintained that the points in that group may be found. If we would rather use polygons to fit directly onto the area of our clusters we do so by replacing the ellipses with the following line of code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = dune_MDS_points, aes(x = x, y = y)) +\n  geom_point(size = 8, shape = 21, fill = \"black\", colour = \"red\") +\n  geom_text(aes(label = site), colour = \"white\") +\n  geom_segment(data = dune_envfit_df, arrow = arrow(length = unit(0.25, \"cm\")),\n               aes(x = 0, y = 0, xend = x, yend = y)) +\n  geom_text(data = dune_envfit_df, colour = \"red\", \n            aes(x = x, y = y, label = factors)) +\n  # The custom made polygons\n  stat_chull(geom = \"polygon\", aes(fill = grp_id), alpha = 0.4) +\n  #\n  labs(x = \"NMDS1\", y = \"NMDS2\")\n```\n:::\n\n\nI'm not super excited about that result either. A third option is to simply change the colour of the points to reflect their grouping.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = dune_MDS_points, aes(x = x, y = y)) +\n  # Changing point aesthetics\n  geom_point(size = 8, aes(colour = grp_id)) +\n  #\n  geom_text(aes(label = site), colour = \"white\") +\n  geom_segment(data = dune_envfit_df, \n               aes(x = 0, y = 0, xend = x, yend = y)) +\n  geom_text(data = dune_envfit_df, colour = \"red\",\n            aes(label = factors)) +\n  labs(x = \"NMDS1\", y = \"NMDS2\", colour = \"Cluster\")\n```\n:::\n\n\nI think this is actually the cleanest way to visualise the data.\n\n## Diversity\n\nIf we are interested in calculating a Shannon-Wiener index on the species diversity found within the dunes we need only one function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiversity(dune)\n```\n:::\n\n\n## ANOSIM\n\nOne final thing. It is also necessary to know if any differences exist between the clusters we have determined for our data. To do this we use the `anosim()` function from the `vegan` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanosim(dune_dist, dune_grp)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}